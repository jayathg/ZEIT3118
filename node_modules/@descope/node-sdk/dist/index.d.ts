import * as _descope_core_js_sdk from '@descope/core-js-sdk';
import _descope_core_js_sdk__default, { DeliveryMethod, UserResponse, SdkResponse, AccessKeyLoginOptions, ExchangeAccessKeyResponse } from '@descope/core-js-sdk';
export { DeliveryMethod, JWTResponse, OAuthProvider, ResponseData, SdkResponse } from '@descope/core-js-sdk';
import { JWTHeaderParameters, KeyLike } from 'jose';

/** Parsed JWT token */
interface Token {
    sub?: string;
    exp?: number;
    iss?: string;
    [claim: string]: unknown;
}
/** All information regarding token including the raw JWT, parsed JWT and cookies */
interface AuthenticationInfo {
    jwt: string;
    token: Token;
    cookies?: string[];
}
declare type DeliveryMethodForTestUser = DeliveryMethod | 'Embedded';

declare type ExpirationUnit = 'minutes' | 'hours' | 'days' | 'weeks';
/**
 * Represents a tenant association for a User or Access Key. The tenantId is required to denote
 * which tenant the user or access key belongs to. The roleNames array is an optional list of
 * roles for the user or access key in this specific tenant.
 */
declare type AssociatedTenant = {
    tenantId: string;
    roleNames: string[];
};
/** The tenantId of a newly created tenant */
declare type CreateTenantResponse = {
    id: string;
};
/**
 * Options to create or update an OIDC application.
 *
 * **Note:** When updating, `id` will be required to perform the operation
 */
declare type OidcApplicationOptions = {
    name: string;
    loginPageUrl: string;
    id?: string;
    description?: string;
    logo?: string;
    enabled?: boolean;
};
/**
 * Options to create or update a SAML application.
 *
 * **Note:** When updating, `id` will be required to perform the operation
 */
declare type SamlApplicationOptions = {
    name: string;
    loginPageUrl: string;
    id?: string;
    description?: string;
    logo?: string;
    enabled?: boolean;
    useMetadataInfo?: boolean;
    metadataUrl?: string;
    entityId?: string;
    acsUrl?: string;
    certificate?: string;
    attributeMapping?: SamlIdpAttributeMappingInfo[];
    groupsMapping?: SamlIdpGroupsMappingInfo[];
    acsAllowedCallbacks?: string[];
    subjectNameIdType?: string;
    subjectNameIdFormat?: string;
};
/**
 * Represents a SAML IDP attribute mapping object. Use this class for mapping Descope attribute
 * to the relevant SAML Assertion attributes matching your expected SP attributes names.
 */
declare type SamlIdpAttributeMappingInfo = {
    name: string;
    type: string;
    value: string;
};
/** Represents a SAML IDP Role Group mapping object. */
declare type SAMLIDPRoleGroupMappingInfo = {
    id: string;
    name: string;
};
/**
 * Represents a SAML IDP groups mapping object. Use this class for mapping Descope roles
 * to the relevant SAML Assertion groups attributes that matching your expected SP groups attributes names.
 */
declare type SamlIdpGroupsMappingInfo = {
    name: string;
    type: string;
    filterType: string;
    value: string;
    roles: SAMLIDPRoleGroupMappingInfo[];
};
/** The ID of a newly created SSO application */
declare type CreateSSOApplicationResponse = {
    id: string;
};
/** An access key that can be used to access descope */
declare type AccessKey = {
    id: string;
    name: string;
    expiredTime: number;
    roleNames: string[];
    keyTenants?: AssociatedTenant[];
    status: string;
    createdTime: number;
    expiresTime: number;
    createdBy: string;
    clientId: string;
    boundUserId?: string;
};
/** Access Key extended details including created key cleartext */
declare type CreatedAccessKeyResponse = {
    key: AccessKey;
    cleartext: string;
};
/** Represents a mapping between a set of groups of users and a role that will be assigned to them */
declare type RoleMapping = {
    groups: string[];
    roleName: string;
};
declare type RoleMappings = RoleMapping[];
/** Represents a mapping between Descope and IDP user attributes */
declare type AttributeMapping = {
    name?: string;
    email?: string;
    phoneNumber?: string;
    group?: string;
};
/** UpdateJWT response with a new JWT value with the added custom claims */
declare type UpdateJWTResponse = {
    jwt: string;
};
/** Represents a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
declare type Tenant = {
    id: string;
    name: string;
    selfProvisioningDomains: string[];
    customAttributes?: Record<string, string | number | boolean>;
    domains?: string[];
    authType?: 'none' | 'saml' | 'oidc';
};
/** Represents settings of a tenant in a project. It has an id, a name and an array of
 * self provisioning domains used to associate users with that tenant.
 */
declare type TenantSettings = {
    selfProvisioningDomains: string[];
    domains?: string[];
    authType?: 'none' | 'saml' | 'oidc';
    sessionSettingsEnabled?: boolean;
    refreshTokenExpiration?: number;
    refreshTokenExpirationUnit?: ExpirationUnit;
    sessionTokenExpiration?: number;
    sessionTokenExpirationUnit?: ExpirationUnit;
    stepupTokenExpiration?: number;
    stepupTokenExpirationUnit?: ExpirationUnit;
    enableInactivity?: boolean;
    InactivityTime?: number;
    InactivityTimeUnit?: ExpirationUnit;
    JITDisabled?: boolean;
};
/** Represents password settings of a tenant in a project. It has the password policy details. */
declare type PasswordSettings = {
    enabled: boolean;
    minLength: number;
    lowercase: boolean;
    uppercase: boolean;
    number: boolean;
    nonAlphaNumeric: boolean;
    expiration: boolean;
    expirationWeeks: number;
    reuse: boolean;
    reuseAmount: number;
    lock: boolean;
    lockAttempts: number;
};
/** Represents OIDC settings of an SSO application in a project. */
declare type SSOApplicationOIDCSettings = {
    loginPageUrl: string;
    issuer: string;
    discoveryUrl: string;
};
/** Represents SAML settings of an SSO application in a project. */
declare type SSOApplicationSAMLSettings = {
    loginPageUrl: string;
    idpCert: string;
    useMetadataInfo: boolean;
    metadataUrl: string;
    entityId: string;
    acsUrl: string;
    certificate: string;
    attributeMapping: SamlIdpAttributeMappingInfo[];
    groupsMapping: SamlIdpGroupsMappingInfo[];
    idpMetadataUrl: string;
    idpEntityId: string;
    idpSsoUrl: string;
    acsAllowedCallbacks: string[];
    subjectNameIdType: string;
    subjectNameIdFormat: string;
};
/** Represents an SSO application in a project. */
declare type SSOApplication = {
    id: string;
    name: string;
    description: string;
    enabled: boolean;
    logo: string;
    appType: string;
    samlSettings: SSOApplicationSAMLSettings;
    oidcSettings: SSOApplicationOIDCSettings;
};
/** Represents a permission in a project. It has a name and optionally a description.
 * It also has a flag indicating whether it is system default or not.
 */
declare type Permission = {
    name: string;
    description?: string;
    systemDefault: boolean;
};
/** Represents a role in a project. It has a name and optionally a description and
 * a list of permissions it grants.
 */
declare type Role = {
    name: string;
    description?: string;
    permissionNames: string[];
    createdTime: number;
    tenantId?: string;
};
/** Search roles based on the parameters */
declare type RoleSearchOptions = {
    tenantIds?: string[];
    roleNames?: string[];
    roleNameLike?: string;
    permissionNames?: string[];
};
/** Represents a group in a project. It has an id and display name and a list of group members. */
declare type Group = {
    id: string;
    display: string;
    members?: GroupMember[];
};
/** Represents a group member. It has loginId, userId and display. */
declare type GroupMember = {
    loginId: string;
    userId: string;
    display: string;
};
declare type Flow = {
    id: string;
    name: string;
    description?: string;
    dsl: any;
    disabled: boolean;
    etag?: string;
};
declare type FlowMetadata = {
    id: string;
    name: string;
    description?: string;
    disabled: boolean;
};
declare type Screen = {
    id: string;
    flowId: string;
    inputs?: any;
    interactions?: any;
    htmlTemplate: any;
};
declare type FlowsResponse = {
    flows: FlowMetadata[];
    total: number;
};
declare type FlowResponse = {
    flow: Flow;
    screens: Screen[];
};
declare type Theme = {
    id: string;
    cssTemplate?: any;
};
declare type ThemeResponse = {
    theme: Theme;
};
declare type GenerateOTPForTestResponse = {
    loginId: string;
    code: string;
};
declare type GenerateMagicLinkForTestResponse = {
    loginId: string;
    link: string;
};
declare type GenerateEnchantedLinkForTestResponse = {
    loginId: string;
    link: string;
    pendingRef: string;
};
declare type GenerateEmbeddedLinkResponse = {
    token: string;
};
declare type AttributesTypes = string | boolean | number;
declare type User = {
    loginId: string;
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    test?: boolean;
    additionalLoginIds?: string[];
    password?: string;
    hashedPassword?: UserPasswordHashed;
};
declare type UserPasswordHashed = {
    bcrypt?: UserPasswordBcrypt;
    pbkdf2?: UserPasswordPbkdf2;
    firebase?: UserPasswordFirebase;
    django?: UserPasswordDjango;
};
declare type UserPasswordBcrypt = {
    hash: string;
};
declare type UserPasswordPbkdf2 = {
    hash: string;
    salt: string;
    iterations: number;
    type: 'sha1' | 'sha256' | 'sha512';
};
declare type UserPasswordFirebase = {
    hash: string;
    salt: string;
    saltSeparator: string;
    signerKey: string;
    memory: number;
    rounds: number;
};
declare type UserPasswordDjango = {
    hash: string;
};
declare type UserMapping = {
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
    group: string;
};
declare type RoleItem = {
    id: string;
    name: string;
};
declare type GroupsMapping = {
    role: RoleItem;
    groups: string[];
};
declare type SSOSettingsResponse = {
    tenantId: string;
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    userMapping: UserMapping;
    groupsMapping: GroupsMapping[];
    redirectUrl: string;
    domains: string[];
    domain: string;
};
declare type SSOSAMLSettingsResponse = {
    idpEntityId: string;
    idpSSOUrl: string;
    idpCertificate: string;
    idpMetadataUrl: string;
    spEntityId: string;
    spACSUrl: string;
    spCertificate: string;
    attributeMapping: AttributeMapping;
    groupsMapping: RoleMappings;
    redirectUrl: string;
};
declare type SSOSettings = {
    tenant: Tenant;
    saml?: SSOSAMLSettingsResponse;
    oidc?: SSOOIDCSettings;
};
declare type OIDCAttributeMapping = {
    loginId?: string;
    name?: string;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    email?: string;
    verifiedEmail?: string;
    username?: string;
    phoneNumber?: string;
    verifiedPhone?: string;
    picture?: string;
};
declare type Prompt = 'none' | 'login' | 'consent' | 'select_account';
declare type SSOOIDCSettings = {
    name: string;
    clientId: string;
    clientSecret?: string;
    redirectUrl?: string;
    authUrl?: string;
    tokenUrl?: string;
    userDataUrl?: string;
    scope?: string[];
    JWKsUrl?: string;
    attributeMapping?: OIDCAttributeMapping;
    manageProviderTokens?: boolean;
    callbackDomain?: string;
    prompt?: Prompt[];
    grantType?: 'authorization_code' | 'implicit';
    issuer?: string;
};
declare type SSOSAMLSettings = {
    idpUrl: string;
    idpCert: string;
    entityId: string;
    roleMappings?: RoleMappings;
    attributeMapping?: AttributeMapping;
};
declare type SSOSAMLByMetadataSettings = {
    idpMetadataUrl: string;
    roleMappings?: RoleMappings;
    attributeMapping?: AttributeMapping;
};
declare type ProviderTokenResponse = {
    provider: string;
    providerUserId: string;
    accessToken: string;
    expiration: number;
    scopes: string[];
};
declare type UserFailedResponse = {
    failure: string;
    user: UserResponse;
};
declare type InviteBatchResponse = {
    createdUsers: UserResponse[];
    failedUsers: UserFailedResponse[];
};
/**
 * Search options to filter which audit records we should retrieve.
 * All parameters are optional. `From` is currently limited to 30 days.
 */
declare type AuditSearchOptions = {
    userIds?: string[];
    actions?: string[];
    excludedActions?: string[];
    devices?: string[];
    methods?: string[];
    geos?: string[];
    remoteAddresses?: string[];
    loginIds?: string[];
    tenants?: string[];
    noTenants?: boolean;
    text?: string;
    from?: number;
    to?: number;
};
/** Audit record response from the audit trail. Occurred is in milliseconds. */
declare type AuditRecord = {
    projectId: string;
    userId: string;
    action: string;
    occurred: number;
    device: string;
    method: string;
    geo: string;
    remoteAddress: string;
    loginIds: string[];
    tenants: string[];
    data: Record<string, any>;
};
declare type UserStatus = 'enabled' | 'disabled' | 'invited';
declare type AuthzNodeExpressionType = 'self' | 'targetSet' | 'relationLeft' | 'relationRight';
/**
 * AuthzNodeExpression holds the definition of a child node
 */
declare type AuthzNodeExpression = {
    neType: AuthzNodeExpressionType;
    relationDefinition?: string;
    relationDefinitionNamespace?: string;
    targetRelationDefinition?: string;
    targetRelationDefinitionNamespace?: string;
};
declare type AuthzNodeType = 'child' | 'union' | 'intersect' | 'sub';
/**
 * AuthzNode holds the definition of a complex relation definition
 */
declare type AuthzNode = {
    nType: AuthzNodeType;
    children?: AuthzNode[];
    expression?: AuthzNodeExpression;
};
/**
 * AuthzRelationDefinition defines a relation within a namespace
 */
declare type AuthzRelationDefinition = {
    name: string;
    complexDefinition?: AuthzNode;
};
/**
 * AuthzNamespace defines an entity in the authorization schema
 */
declare type AuthzNamespace = {
    name: string;
    relationDefinitions: AuthzRelationDefinition[];
};
/**
 * AuthzSchema holds the full schema (all namespaces) for a project
 */
declare type AuthzSchema = {
    name?: string;
    namespaces: AuthzNamespace[];
};
/**
 * AuthzUserQuery represents a target of a relation for ABAC (query on users)
 */
declare type AuthzUserQuery = {
    tenants?: string[];
    roles?: string[];
    text?: string;
    statuses?: UserStatus[];
    ssoOnly?: boolean;
    withTestUser?: boolean;
    customAttributes?: Record<string, any>;
};
/**
 * AuthzRelation defines a relation between resource and target
 */
declare type AuthzRelation = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target?: string;
    targetSetResource?: string;
    targetSetRelationDefinition?: string;
    targetSetRelationDefinitionNamespace?: string;
    query?: AuthzUserQuery;
};
/**
 * AuthzRelationQuery queries the service if a given relation exists
 */
declare type AuthzRelationQuery = {
    resource: string;
    relationDefinition: string;
    namespace: string;
    target: string;
    hasRelation?: boolean;
};
/**
 * AuthzModified has the list of resources and targets that were modified since given time returned from GetModified
 */
declare type AuthzModified = {
    resources: string[];
    targets: string[];
    schemaChanged: boolean;
};
declare type CloneProjectResponse = {
    projectId: string;
    projectName: string;
    tag?: string;
};

interface UserOptions {
    email?: string;
    phone?: string;
    displayName?: string;
    roles?: string[];
    userTenants?: AssociatedTenant[];
    customAttributes?: Record<string, AttributesTypes>;
    picture?: string;
    verifiedEmail?: boolean;
    verifiedPhone?: boolean;
    givenName?: string;
    middleName?: string;
    familyName?: string;
    additionalLoginIds?: string[];
    ssoAppIds?: string[];
}

/** Common Error Codes */
declare const descopeErrors: {
    badRequest: string;
    missingArguments: string;
    invalidRequest: string;
    invalidArguments: string;
    wrongOTPCode: string;
    tooManyOTPAttempts: string;
    enchantedLinkPending: string;
    userNotFound: string;
};

/** Configuration arguments which include the Descope core SDK args and an optional management key */
declare type NodeSdkArgs = Parameters<typeof _descope_core_js_sdk__default>[0] & {
    managementKey?: string;
    publicKey?: string;
};
declare const nodeSdk: {
    ({ managementKey, publicKey, ...config }: NodeSdkArgs): {
        management: {
            user: {
                create: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                createTestUser: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                invite: {
                    (loginId: string, options?: UserOptions & {
                        inviteUrl?: string;
                        sendMail?: boolean;
                        sendSMS?: boolean;
                    }): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                };
                inviteBatch: (users: User[], inviteUrl?: string, sendMail?: boolean, sendSMS?: boolean) => Promise<SdkResponse<InviteBatchResponse>>;
                update: {
                    (loginId: string, options?: UserOptions): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                    (loginId: string, email?: string, phone?: string, displayName?: string, roles?: string[], userTenants?: AssociatedTenant[], customAttributes?: Record<string, AttributesTypes>, picture?: string, verifiedEmail?: boolean, verifiedPhone?: boolean, givenName?: string, middleName?: string, familyName?: string, additionalLoginIds?: string[]): Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                }; /**
                 * Make sure that all given roles exist on the parsed JWT tenant claims
                 * @param authInfo JWT parsed info
                 * @param tenant tenant to validate the roles for
                 * @param roles list of roles to make sure they exist on te JWT claims
                 * @returns true if all roles exist, false otherwise
                 */
                delete: (loginId: string) => Promise<SdkResponse<never>>;
                deleteByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deleteAllTestUsers: () => Promise<SdkResponse<never>>;
                load: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                loadByUserId: (userId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                logoutUser: (loginId: string) => Promise<SdkResponse<never>>;
                logoutUserByUserId: (userId: string) => Promise<SdkResponse<never>>;
                searchAll: (tenantIds?: string[], roles?: string[], limit?: number, page?: number, testUsersOnly?: boolean, withTestUser?: boolean, customAttributes?: Record<string, AttributesTypes>, statuses?: UserStatus[], emails?: string[], phones?: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                search: (searchReq: {
                    page?: number;
                    limit?: number;
                    sort?: {
                        field: string;
                        desc?: boolean;
                    }[];
                    text?: string;
                    emails?: string[];
                    phones?: string[];
                    statuses?: UserStatus[];
                    roles?: string[];
                    tenantIds?: string[];
                    customAttributes?: Record<string, AttributesTypes>;
                    withTestUser?: boolean;
                    testUsersOnly?: boolean;
                    ssoAppIds?: string[];
                }) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse[]>>;
                getProviderToken: (loginId: string, provider: string) => Promise<SdkResponse<ProviderTokenResponse>>;
                activate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                deactivate: (loginId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateLoginId: (loginId: string, newLoginId?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateEmail: (loginId: string, email: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePhone: (loginId: string, phone: string, isVerified: boolean) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateDisplayName: (loginId: string, displayName?: string, givenName?: string, middleName?: string, familyName?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updatePicture: (loginId: string, picture: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                updateCustomAttribute: (loginId: string, attributeKey: string, attributeValue: AttributesTypes) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeRoles: (loginId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenant: (loginId: string, tenantId: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeTenantRoles: (loginId: string, tenantId: string, roles: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                addSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                setSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                removeSSOapps: (loginId: string, ssoAppIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
                generateOTPForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateOTPForTestResponse>>;
                generateMagicLinkForTestUser: (deliveryMethod: DeliveryMethodForTestUser, loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateMagicLinkForTestResponse>>;
                generateEnchantedLinkForTestUser: (loginId: string, uri: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>>;
                generateEmbeddedLink: (loginId: string, customClaims?: Record<string, any>) => Promise<SdkResponse<GenerateEmbeddedLinkResponse>>;
                setTemporaryPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                setActivePassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                setPassword: (loginId: string, password: string) => Promise<SdkResponse<never>>;
                expirePassword: (loginId: string) => Promise<SdkResponse<never>>;
                removeAllPasskeys: (loginId: string) => Promise<SdkResponse<never>>;
                history: (userIds: string[]) => Promise<SdkResponse<_descope_core_js_sdk.UserHistoryResponse[]>>;
            };
            project: {
                updateName: (name: string) => Promise<SdkResponse<never>>;
                clone: (name: string, tag?: "production") => Promise<SdkResponse<CloneProjectResponse>>;
                export: () => Promise<SdkResponse<Record<string, any>>>;
                import: (files: Record<string, any>) => Promise<SdkResponse<never>>;
            };
            accessKey: {
                create: (name: string, expireTime: number, roles?: string[], keyTenants?: AssociatedTenant[], userId?: string, customClaims?: Record<string, any>) => Promise<SdkResponse<CreatedAccessKeyResponse>>;
                load: (id: string) => Promise<SdkResponse<AccessKey>>;
                searchAll: (tenantIds?: string[]) => Promise<SdkResponse<AccessKey[]>>;
                update: (id: string, name: string) => Promise<SdkResponse<AccessKey>>;
                deactivate: (id: string) => Promise<SdkResponse<never>>;
                activate: (id: string) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
            };
            tenant: {
                create: (name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<CreateTenantResponse>>;
                createWithId: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<never>>;
                update: (id: string, name: string, selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<Tenant>>;
                loadAll: () => Promise<SdkResponse<Tenant[]>>;
                searchAll: (ids?: string[], names?: string[], selfProvisioningDomains?: string[], customAttributes?: Record<string, AttributesTypes>) => Promise<SdkResponse<Tenant[]>>;
                getSettings: (tenantId: string) => Promise<SdkResponse<TenantSettings>>;
                configureSettings: (tenantId: string, settings: TenantSettings) => Promise<SdkResponse<never>>;
            };
            ssoApplication: {
                createOidcApplication: (options: OidcApplicationOptions) => Promise<SdkResponse<CreateSSOApplicationResponse>>;
                createSamlApplication: (options: SamlApplicationOptions) => Promise<SdkResponse<CreateSSOApplicationResponse>>;
                updateOidcApplication: (options: OidcApplicationOptions & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                updateSamlApplication: (options: SamlApplicationOptions & {
                    id: string;
                }) => Promise<SdkResponse<never>>;
                delete: (id: string) => Promise<SdkResponse<never>>;
                load: (id: string) => Promise<SdkResponse<SSOApplication>>;
                loadAll: () => Promise<SdkResponse<SSOApplication[]>>;
            };
            sso: {
                getSettings: (tenantId: string) => Promise<SdkResponse<SSOSettingsResponse>>;
                deleteSettings: (tenantId: string) => Promise<SdkResponse<never>>;
                configureSettings: (tenantId: string, idpURL: string, idpCert: string, entityId: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMetadata: (tenantId: string, idpMetadataURL: string, redirectURL: string, domains: string[]) => Promise<SdkResponse<never>>;
                configureMapping: (tenantId: string, roleMappings?: RoleMappings, attributeMapping?: AttributeMapping) => Promise<SdkResponse<never>>;
                configureOIDCSettings: (tenantId: string, settings: SSOOIDCSettings, domains?: string[]) => Promise<SdkResponse<never>>;
                configureSAMLSettings: (tenantId: string, settings: SSOSAMLSettings, redirectUrl?: string, domains?: string[]) => Promise<SdkResponse<never>>;
                configureSAMLByMetadata: (tenantId: string, settings: SSOSAMLByMetadataSettings, redirectUrl?: string, domains?: string[]) => Promise<SdkResponse<never>>;
                loadSettings: (tenantId: string) => Promise<SdkResponse<SSOSettings>>;
            };
            jwt: {
                update: (jwt: string, customClaims?: Record<string, any>) => Promise<SdkResponse<UpdateJWTResponse>>;
                impersonate: (impersonatorId: string, loginId: string, validateConsent: boolean) => Promise<SdkResponse<UpdateJWTResponse>>;
            };
            permission: {
                create: (name: string, description?: string) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string) => Promise<SdkResponse<never>>;
                delete: (name: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Permission[]>>;
            };
            password: {
                getSettings: (tenantId: string) => Promise<SdkResponse<PasswordSettings>>;
                configureSettings: (tenantId: string, settings: PasswordSettings) => Promise<SdkResponse<never>>;
            };
            role: {
                create: (name: string, description?: string, permissionNames?: string[], tenantId?: string) => Promise<SdkResponse<never>>;
                update: (name: string, newName: string, description?: string, permissionNames?: string[], tenantId?: string) => Promise<SdkResponse<never>>;
                delete: (name: string, tenantId?: string) => Promise<SdkResponse<never>>;
                loadAll: () => Promise<SdkResponse<Role[]>>;
                search: (options: RoleSearchOptions) => Promise<SdkResponse<Role[]>>;
            };
            group: {
                loadAllGroups: (tenantId: string) => Promise<SdkResponse<Group[]>>;
                loadAllGroupsForMember: (tenantId: string, userIds: string[], loginIds: string[]) => Promise<SdkResponse<Group[]>>;
                loadAllGroupMembers: (tenantId: string, groupId: string) => Promise<SdkResponse<Group[]>>;
            };
            flow: {
                list: () => Promise<SdkResponse<FlowsResponse>>;
                delete: (flowIds: string[]) => Promise<SdkResponse<never>>;
                export: (flowId: string) => Promise<SdkResponse<FlowResponse>>;
                import: (flowId: string, flow: Flow, screens?: Screen[]) => Promise<SdkResponse<FlowResponse>>;
            };
            theme: {
                export: () => Promise<SdkResponse<ThemeResponse>>;
                import: (theme: Theme) => Promise<SdkResponse<ThemeResponse>>;
            };
            audit: {
                search: (searchOptions: AuditSearchOptions) => Promise<SdkResponse<AuditRecord[]>>;
            };
            authz: {
                saveSchema: (schema: AuthzSchema, upgrade: boolean) => Promise<SdkResponse<never>>;
                deleteSchema: () => Promise<SdkResponse<never>>;
                loadSchema: () => Promise<SdkResponse<AuthzSchema>>;
                saveNamespace: (namespace: AuthzNamespace, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteNamespace: (name: string, schemaName?: string) => Promise<SdkResponse<never>>;
                saveRelationDefinition: (relationDefinition: AuthzRelationDefinition, namespace: string, oldName?: string, schemaName?: string) => Promise<SdkResponse<never>>;
                deleteRelationDefinition: (name: string, namespace: string, schemaName?: string) => Promise<SdkResponse<never>>;
                createRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelations: (relations: AuthzRelation[]) => Promise<SdkResponse<never>>;
                deleteRelationsForResources: (resources: string[]) => Promise<SdkResponse<never>>;
                hasRelations: (relationQueries: AuthzRelationQuery[]) => Promise<SdkResponse<AuthzRelationQuery[]>>;
                whoCanAccess: (resource: string, relationDefinition: string, namespace: string) => Promise<SdkResponse<string[]>>;
                resourceRelations: (resource: string) => Promise<SdkResponse<AuthzRelation[]>>;
                targetsRelations: (targets: string[]) => Promise<SdkResponse<AuthzRelation[]>>;
                whatCanTargetAccess: (target: string) => Promise<SdkResponse<AuthzRelation[]>>;
                getModified: (since: Date) => Promise<SdkResponse<AuthzModified>>;
            };
        };
        getKey: (header: JWTHeaderParameters) => Promise<KeyLike | Uint8Array>;
        validateJwt: (jwt: string) => Promise<AuthenticationInfo>;
        validateSession: (sessionToken: string) => Promise<AuthenticationInfo>;
        refreshSession: (refreshToken: string) => Promise<AuthenticationInfo>;
        validateAndRefreshSession: (sessionToken?: string, refreshToken?: string) => Promise<AuthenticationInfo>;
        exchangeAccessKey: (accessKey: string, loginOptions?: AccessKeyLoginOptions) => Promise<AuthenticationInfo>;
        validatePermissions: (authInfo: AuthenticationInfo, permissions: string[]) => boolean;
        getMatchedPermissions: (authInfo: AuthenticationInfo, permissions: string[]) => string[];
        validateTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => boolean;
        getMatchedTenantPermissions: (authInfo: AuthenticationInfo, tenant: string, permissions: string[]) => string[];
        validateRoles: (authInfo: AuthenticationInfo, roles: string[]) => boolean;
        getMatchedRoles: (authInfo: AuthenticationInfo, roles: string[]) => string[];
        validateTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => boolean;
        getMatchedTenantRoles: (authInfo: AuthenticationInfo, tenant: string, roles: string[]) => string[];
        accessKey: {
            exchange: (accessKey: string, loginOptions?: AccessKeyLoginOptions) => Promise<SdkResponse<ExchangeAccessKeyResponse>>;
        };
        otp: {
            verify: {
                sms: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                whatsapp: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
                email: (loginId: string, code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                sms: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T extends boolean>(loginId: string, email: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T;
                    onMergeUseExisting?: T extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_1 extends boolean>(loginId: string, phone: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_1;
                        onMergeUseExisting?: T_1 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        magicLink: {
            verify: (token: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signIn: {
                sms: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUp: {
                sms: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI: string, user?: {
                    email?: string;
                    name?: string;
                    givenName?: string;
                    middleName?: string;
                    familyName?: string;
                    phone?: string;
                }, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            signUpOrIn: {
                sms: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                whatsapp: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedPhone: string;
                }>>;
                email: (loginId: string, URI?: string, signUpOptions?: {
                    customClaims?: Record<string, any>;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
            };
            update: {
                email: <T_2 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_2;
                    onMergeUseExisting?: T_2 extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<{
                    maskedEmail: string;
                }>>;
                phone: {
                    sms: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                    whatsapp: <T_3 extends boolean>(loginId: string, phone: string, URI?: string, token?: string, updateOptions?: {
                        addToLoginIDs?: T_3;
                        onMergeUseExisting?: T_3 extends true ? boolean : never;
                        templateOptions?: {
                            [x: string]: string;
                        };
                    }) => Promise<SdkResponse<{
                        maskedPhone: string;
                    }>>;
                };
            };
        };
        enchantedLink: {
            verify: (token: string) => Promise<SdkResponse<never>>;
            signIn: (loginId: string, URI?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            signUpOrIn: (loginId: string, URI?: string, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            signUp: (loginId: string, URI?: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }, signUpOptions?: {
                customClaims?: Record<string, any>;
                templateOptions?: {
                    [x: string]: string;
                };
            }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            waitForSession: (pendingRef: string, config?: {
                pollingIntervalMs: number;
                timeoutMs: number;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            update: {
                email: <T_4 extends boolean>(loginId: string, email: string, URI?: string, token?: string, updateOptions?: {
                    addToLoginIDs?: T_4;
                    onMergeUseExisting?: T_4 extends true ? boolean : never;
                    templateOptions?: {
                        [x: string]: string;
                    };
                }) => Promise<SdkResponse<_descope_core_js_sdk.EnchantedLinkResponse>>;
            };
        };
        oauth: {
            start: ((provider: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>) & {
                facebook: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                github: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                google: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                microsoft: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                gitlab: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                apple: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                discord: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                linkedin: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
                slack: (redirectURL?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            };
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            startNative: (provider: string, loginOptions?: _descope_core_js_sdk.LoginOptions) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            finishNative: (provider: string, stateId: string, user?: string, code?: string, idToken?: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
        };
        saml: {
            start: (tenantIdOrEmail: string, redirectUrl?: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.URLResponse>>;
            exchange: (code: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
        };
        totp: {
            signUp: (loginId: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
            verify: (loginId: string, code: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                refreshJwt?: string;
                cookies?: string[];
            }>>;
            update: (loginId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.TOTPResponse>>;
        };
        webauthn: {
            signUp: {
                start: (loginId: string, origin: string, name: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signIn: {
                start: (loginId: string, origin: string, loginOptions?: _descope_core_js_sdk.LoginOptions, token?: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
                    refreshJwt?: string;
                    cookies?: string[];
                }>>;
            };
            signUpOrIn: {
                start: (loginId: string, origin: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
            };
            update: {
                start: (loginId: string, origin: string, token: string) => Promise<SdkResponse<{
                    transactionId: string;
                    options: string;
                    create: boolean;
                }>>;
                finish: (transactionId: string, response: string) => Promise<SdkResponse<_descope_core_js_sdk.ResponseData>>;
            };
        };
        password: {
            signUp: (loginId: string, password: string, user?: {
                email?: string;
                name?: string;
                givenName?: string;
                middleName?: string;
                familyName?: string;
                phone?: string;
            }) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            signIn: (loginId: string, password: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            sendReset: (loginId: string, redirectUrl?: string, templateOptions?: {
                [x: string]: string;
            }) => Promise<SdkResponse<{
                resetMethod: string;
                pendingRef?: string;
                linkId?: string;
                maskedEmail: string;
            }>>;
            update: (loginId: string, newPassword: string, token?: string) => Promise<SdkResponse<never>>;
            replace: (loginId: string, oldPassword: string, newPassword: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
            policy: () => Promise<SdkResponse<{
                minLength: number;
                lowercase: boolean;
                uppercase: boolean;
                number: boolean;
                nonAlphanumeric: boolean;
            }>>;
        };
        flow: {
            start: (flowId: string, options?: {
                redirectUrl?: string;
                location?: string;
                tenant?: string;
                deviceInfo?: {
                    webAuthnSupport?: boolean;
                };
                lastAuth?: {
                    authMethod?: "saml" | "otp" | "oauth" | "totp" | "webauthn" | "magiclink" | "enchantedlink";
                    oauthProvider?: string;
                    name?: string;
                    loginId?: string;
                };
                redirectAuth?: {
                    callbackUrl: string;
                    codeChallenge: string;
                };
                oidcIdpStateId?: string;
                preview?: boolean;
                samlIdpStateId?: string;
                samlIdpUsername?: string;
                ssoAppId?: string;
                oidcLoginHint?: string;
                abTestingKey?: number;
                startOptionsVersion?: number;
                client?: Record<string, any>;
            }, conditionInteractionId?: string, interactionId?: string, version?: number, componentsVersion?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
            next: (executionId: string, stepId: string, interactionId: string, version?: number, componentsVersion?: string, input?: {
                [x: string]: string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | (string | number | boolean | any)[])[])[])[])[])[])[])[])[])[])[];
            }) => Promise<SdkResponse<_descope_core_js_sdk.FlowResponse>>;
        };
        refresh: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse & {
            refreshJwt?: string;
            cookies?: string[];
        }>>;
        selectTenant: (tenantId: string, token?: string) => Promise<SdkResponse<_descope_core_js_sdk.JWTResponse>>;
        logout: (token?: string) => Promise<SdkResponse<never>>;
        logoutAll: (token?: string) => Promise<SdkResponse<never>>;
        me: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserResponse>>;
        history: (token?: string) => Promise<SdkResponse<_descope_core_js_sdk.UserHistoryResponse>>;
        isJwtExpired: (token: string) => boolean;
        getTenants: (token: string) => string[];
        getJwtPermissions: (token: string, tenant?: string) => string[];
        getJwtRoles: (token: string, tenant?: string) => string[];
        httpClient: {
            get: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            post: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            put: (path: string, body?: any, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            delete: (path: string, config?: {
                headers?: HeadersInit;
                queryParams?: {
                    [key: string]: string;
                };
                token?: string;
            }) => Promise<Response>;
            hooks?: {
                beforeRequest?: (config: _descope_core_js_sdk.RequestConfig) => _descope_core_js_sdk.RequestConfig;
                afterRequest?: (req: _descope_core_js_sdk.RequestConfig, res: Response) => void | Promise<void>;
            };
        };
    };
    /** Descope SDK client with delivery methods enum.
     *
     * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}
     * @example Usage
     *
     * ```js
     * import descopeSdk from '@descope/node-sdk';
     *
     * const myProjectId = 'xxx';
     * const sdk = descopeSdk({ projectId: myProjectId });
     *
     * const userLoginId = 'loginId';
     * sdk.otp.signIn.email(userLoginId);
     * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);
     * ```
     */
    RefreshTokenCookieName: string;
    SessionTokenCookieName: string;
};

export { AuthenticationInfo, nodeSdk as default, descopeErrors };
